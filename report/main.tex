\documentclass[11pt]{article}
\usepackage[english]{babel}

% \usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{url}

\usepackage{caption}
\usepackage{subcaption}

\usepackage{tikz}
\usepackage{amsmath}
\usetikzlibrary{arrows}
\usepackage{verbatim}

\definecolor{codegray}{gray}{0.9}
\newcommand{\code}[1]{\colorbox{codegray}{\texttt{#1}}}

\pagestyle{fancy}

\makeatletter

\begin{document}

\pagenumbering{gobble}
\input{title}

% \thispagestyle{empty}
% \tableofcontents
% \newpage
\pagenumbering{arabic}
\setcounter{page}{1}
\section{Introduction}

There is a large class of problems that consist in detecting wheter a particular state in a computation can be reached and need to be detected.
All of those problems can be considered as subclasses of a well known abstract problem in distributed systems called \textit{Global Predicate Evaluation} (GPE). Its goal is to determine whether the global state of a distributed system satisfies some predicate $\Phi$. Those predicates might be related to the state of the system itself such as identify wheter the system is deadlocked or might be related to the state of the computation that is running among a set of processes. A point that all those subclasses have in common is that all those properties can be encoded in terms of variables. GPE consists in evaluate a predicate over them, so compare the value that those variables have with respect to a given condition. There are two different strategies for solving GPE: one is based on a process called monitor, which actively queries the other processes in order to gather enough information to evaluate the predicate; the other strategy is based on a monitor that passively observes the system and waits for notifications sent by other processes whenever some events are related to the given predicate. Choose among one or the other strategy depends on the underlying distributed system, the communication channels, and other details.

In order to inform the monitor about variable changes, processes have to send messages containing at least information related to the predicate which has to be evaluated. However, this is not the only information they need to carry on. Based on the synchrony or the asynchrony of the model one has to keep into consideration problems that may happen such as message ordering beetween a process and the monitor or between processes themselves. Moreover, messages can also be delayed or lost while processes may fails. Hence, one important component in the system to keep into consideration is the notion of time. Different time measures for events are considered in solving the GPE: global clock, logical clocks and vector clocks. In addition, time is used to collect only observation that are consistent, so observation that could have taken place during an execution.

Consistency of observation is an important property that needs to be satisfied because predicate values are meaningful only when they are evaluated in consistent global states. The monitor has the core role of collect only the consistent global states of the running computation. Based on those states the monitor defines a lattice, an algebraic structure which consists of a partially ordered set (poset) organized in levels with an unique upper bound and an unique lower bound.

\subsection{Goals}

The reasons which have motivated our group to conduct a study on this topic and the objectives which we have set ourselves are the following:
\begin{enumerate}
\item \textbf{Simulate a distributed computation}. Structure the project in such a way that users can define how the simulation has to be executed and how long it has to last.
\item \textbf{Develop an application as dinamic as possible}. Allow users to define how many peers will run over the system and their behaviour: establish the probability of executing an internal event rather than a message exchange.
\item \textbf{Evaluate a Global Predicate among all the consistent global states}. Collect only consistent global states so the monitor can evaluate a given predicate over them.
\item \textbf{Display a lattice of the computations}. Display the events executed during the simulation in a lattice structure so users can see all the possible runs that could have been executed and the states satisfying the given predicate.
\end{enumerate}

\subsection{Results}

We developed a simple solution to the GPE problem based on a monitor that passively observes the distributed computation. The project has been develop in Java using JDK version's $1.7$ in combination with the Akka framework which allowed us to build an highly concurrent, distributed, and resilient message-driven application\footnote{\url{http://akka.io}}. Our work consists in a simulation of a distributed system in which peers exchange messages and execute internal events while the monitor waits until the end of the simulation. Messages are labelled with a vector clock and contain information related to the predicate that the user wants to evaluate. In particolar, we adopted a simple strategy for structure messages in a way that they were able to transport all the information needed at the very end of the simulation.

Once the simulation ends, the monitor collects the histories of events from all the peers and organize them into a \textit{partially ordered set} (poset) based on the vector clocks recorded in the messages. Once the poset is created, the monitor transform the poset into a lattice that can be seen graphically by the user. Finally, an analysis of the lattice is conducted: the non-stable predicate given by the user is analized by traversing the lattice (considered as a directed graph) and evaluated among all its possible paths. In this phase we considered either predicates that hold in at least one global state (Definitely) and the ones that hold in all the consistent observations. To conclude, as result we show to the user two pictures that represent lattices of the observed computation with and without the analysis of the predicate.

\subsection{Outline}

The outline of this report is structured as follows. Section 2 describes the problem of GPE, as one of the core problem in distributed system. Section 3 explains details about the solution we propose, the problems we faced, the strategies and assumptions we adopted to overcome them. In this section we do not go deep into the implementation details, instead we will focus on the logics behind our strategies. In Section 4 we will show some experimental evaluations of our implementation. The last section states the conclusion of our work and ideas on how we could improve our solution with techniques based on high-level operators that run in parallel.

\section{The Solution}

We developed an application using the Akka framework which emphasises the concept of \textit{actors} as entities that are independet one each other. In fact, in our project actors can make local decisions, execute events or send messages to other actors. Our solution is based on the fact that a user can specify the duration of the distributed computation and the behaviour of the actors in the system. In our implementation, actors are are both peers and monitor who partecipates in the simulation and interact each other use purely message passing. An important note is that everything in Akka is asynchronous\footnote{\url{http://doc.akka.io/docs/akka/2.4/general/remoting.html}}.

Altough it is a very simple implementation for solving the GPE problem, different options on how to develop our project were considered. We started developing a real P2P system by running peers for a period of time equal to the one specified by the user. Once this period of time elapsed, the peers send all their history of events to the monitor which evaluates a given predicate on the global states built.

The problem we faced developing this solution was that if the user specifies a period of time long enough, no evaluation is performed until this time elapses. Hence, the user has the costraint of waiting for a period of time equal to the one he specified.

Based on the problem stated above, we decided to refine our implementation and we developed a simulated distributed system. As before, the user specifies the duration of the simulation. However, rather than running peers for a well known period of time, each peer simulates its behaviour during a period of time equal to the one specified by scheduling events in the future. As soon as the last scheduled event is far away in the future from the end of the simulation, the peers simulation ends and the history of events collected is sent to the monitor. In addition, as soon as the monitor collects messages and evaluates a predicate over the consistent global states collected, the execution ends. In this way, we allow users to simulate a long distributed computation without waste his time.

\subsection{Assumptions}

We decided to work under an asynchronous system, the weakest possible model for a distributed network, because it enables us to estabilish upper bounds on the cost of solving problems in distributed systems\cite{Babaoglu}. Because we are dealing with this model we have to deal with the problems that might arise during the execution of distributed computations. In fact, those systems rule out the possibility of processes to maintaining syncronized local clocks so communication remains the only possible mechanism for synchronization in such systems. However, there are no bounds on the relative speeds of processes and there exist no bounds on message delays. Hence, in order to assure that the project works on those systems, we posed the following assumptions for the underlying system and the communication:

\begin{enumerate}
\item \textbf{Actors are correct}. Both the peers and the monitor are correct: actors cannot be faulty so they cannot fail or behaviour in a bizantine way.
\item \textbf{The communication network is strongly connected}. Every peer can communicate directly with every other peer.
\item \textbf{Messages sent are at-most-once delivered}. Based on the Akka framework, at-most-once delivery means that for each message handed to the mechanism, that message is delivered zero or one times; it means that messages may be lost.
\item \textbf{Message ordering is mantained per sender-receiver pair}. For a given pair of actors, messages sent directly from the first to the second will not be received out-of-order. Hence, message buffers between pair of actors are FIFO.
\end{enumerate}

\subsection{Initialization}

Each simulation starts by executing the \textbf{Simulator} class. Firstly, it acquires the configuration specified by the user such as the number of peers in the actual system, the duration of the simulation and more. Secondly, it creates an actor system which generates the peers and the monitor as its children, and then sends a \textbf{StartMessage} to them in order to initialize the actors. When the monitor receives the \textit{StartMessage} it starts listening and waiting for \textbf{EndMessages} sent by all the peers at the end of their simulation. On the other hand, once a peer received a \textit{StartMessage} it initializes its vector clock and it can start sending messages to its neighbours.
Although this is a simple protocol in which StartMessages and EndMessages estabilish respectively the start and the end of the simulation, it is not difficult to understand that this procedure may cause problems. In order to explain what may happen, let's describe it in a scenario.

\vspace{0.2cm}
\emph{``Suppose that the actors in the system are two peers and the monitor. The actor system sends a StartMessage to all of them but due to the asynchrony of the underlying distributed system, one of the message sent to a peer is delayed. The peer who received the message first initialize its vector clock and start sending messages to the other peer who does not received yet the StartMessage. If the receipient peer received the message from the peer before the StartMessage sent by the monitor arrived, it cannot update its vector clock because it was not initialized before.''}
\vspace{0.2cm}

\input{worst_case_scenario}

\noindent
Figure \ref{fig:worst_case} shows the problem described in the above scenario. StartMessages are sent by the system actor but one of them arrives earlier than the other. Between the two events a message is exchanged and the update of a vector clock is not possible. We overcomed this problem with a simple solution based on the notion of \textit{common knowledge}: ``we want the other know that I am ready to start the simulation''.

\input{worst_case_scenario_solved}

\noindent
Figure \ref{fig:worst_case_solved} displays how we solved the problem related to Figure \ref{fig:worst_case}. The first time a StartMessage is received, each peer initializes its vector clock and sends another StartMessage to everybody else in order to share common knowledge. This procedure is executed only once, the other StartMessages received are ignored. The assumptions made in Section 2 allow us to reason about the correctness of this protocol because message ordering is mantained per sender-receiver pair.

\subsection{The simulation}

Every time users execute our implementation, a simulation is run. The simulation starts once the initialization phase ends, in other words once each peer in the system has initialized its vector clocks and has sent a StartMessage to every other peer. During the simulation, peers play the main role: they can communicate each other by sending \textbf{Messages} or they can decide to execute internal \textbf{Events}. In fact, each peer has the possibility either to chose randomly a recipient for a message from the set of neighbours or execute an event based on given probabiliy defined by users. However, both the action are scheduled in the near future, meaning that each peer decides when execute the event based on the remaining time of the simulation. This is possible because the duration of the simultation is decided at priori by the user and the peers know it because it was stored in the \textit{StartMessage} previously received. In order to schedule events, each peer maintains a list of events. Each time the peer schedule a new event, it adds this event into that list. Figure \ref{fig:events} displays the history of events scheduled by a peer.

\input{events_history}

\noindent
Each peer is independent from the others, and a possible execution of internal events in combination with messages exchanged between two peers can be seen in the Figure \ref{fig:time_space_diagrams}. While the first picture on the left represent a sequence of events labbeled with the canonical enumeration, the picture on the right shows the same sequence with events labbeled with their vector clocks.

\begin{figure}[ht]
	\centering
	\begin{minipage}{.5\textwidth}
	  \scalebox{.8}{\input{simulation_example}}
	\end{minipage}%
	\begin{minipage}{.5\textwidth}
	  \scalebox{.8}{\input{simulation_example_vc}}
	\end{minipage}
	\caption{Two time-space diagrams: the one on the left represents a sequence of events labelled using the canonical enumeration, the one on the right instead shows events labelled with their vector clocks.}
	\label{fig:time_space_diagrams}
\end{figure}

\noindent
The scheduling of events is made possible using the Akka API method: \\ \vspace{0.2cm}
\centerline{\code{system().scheduler().scheduleOnce()}.}\\
\noindent
As written in the documentation\footnote{\url{http://doc.akka.io/docs/akka/2.4/java/scheduler.html}}, this method returns an instance of Scheduler which is unique per ActorSystem and is used internally for scheduling things to happen at specific points in time. As can be seen in Figure \ref{fig:scheduler}, the simulation is a loop that schedules actions in the future and ends when the next action is scheduled after the end of the simulation. At the very beginning of the simulation the variable \textit{nextAction} is set to zero, meaning that the simulation is just started. Then each time the loop is entered, a random time in the future is choosen between \textit{0} and \textit{DELTA\_TIME}. As soon as this period of time becomes shorter, the number of events executed during the simulation increases. Once a nextAction is scheduled in the future, the peer

\begin{figure}[!ht]
\includegraphics[width=\textwidth]{scheduler}
\caption{The simulation code.}
\label{fig:scheduler}
\end{figure}

\noindent
As we stated, events come in two flavors and are described in the \textbf{Event} class. Each event has an istance of the \textbf{VectorClock} class, an identifier of the peer who executed the event and a variable value which changes along the simulation. Also this variable is related to a probability: users specify the probability that an event executes an internal event rather than a message exchange. Based on this and a randomize procedure each time the peer decides that an event in the future will happen, it choose among the two possibilities and repeat the precedure.

\section{Lattice creation}

\section{Predicate evaluation}

\section{Conclusion}

\bibliographystyle{abbrv}
\bibliography{bibliography}

\end{document}
